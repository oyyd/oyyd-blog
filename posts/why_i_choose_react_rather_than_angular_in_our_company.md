#为什么我们选择了React来做前端

__前言：__

很早以前，我[曾经写过自己对React的看法]()，但那时候自己基本是囫囵吞枣，
只是去看了React最明显的那些特性，完全没有去尝试深入理解其中的设计思想。
其结果便是我完全没有理解到React的优点。直到最近，我们公司和其他大多数初创
公司一样，需要真正地正视前端开发中的问题，并开始进行重构。这时我不得不
从我熟悉的Angular和另一个不少大牛极力推荐的框架——React中作出选择。
于是在仔细思考我们开发中的问题，并结合了他人的看法之后，我选择了React。

这里特别推荐[jlongster的这篇关于React的文章]()。

当然首先让我们从稍远一点的话题开始。

##只用原生（或jQuery）开发时遇到的问题

__缺少有效抽象__

当一个项目刚刚开始时，用原生js进行开发一般不会遇到特别严重的问题。但当
项目进行了一段时间以后。我们的leader曾经说过的（近似）：我觉得看java（服务器上的）
和android的代码都很简单，但是javascript的代码太难看了。

我们可以看看我们去修改一个功能或修复一个bug时的一般性做法：

1. 寻找DOM（在浏览器审查元素）

2. 看一下这个DOM上比较像钩子的属性（`id`, `class`, `role`, `data-xxx`）

3. 搜索代码中用了这个钩子的地方（基本上通过文本搜索找`$()`）

4. 若命中则进入下一个地方，否则从1, 2, 3中的某一步重新开始，直到命中。

而即便你找到了要修改代码，如果你没有遍历上述流程中的每一种情况，你就很难保证你没有
遗漏其他情况。特别是在修改他人的代码时，你很难保证自己做出的修改是完整的、没有副作用的。

产生这一问题的原因，因为抽象混乱，或者说，不仔细考虑代码怎么写的话，就根本没有抽象。
这就导致了我们在看代码时，虽然很明确每一个小操作的作用，但自顶至底来看，
却很难明确每一个操作的目的。

本身javascript的特点和历史原因就导致了不使用一套框架代码的 这也是为什么我觉得在生产
环境中使用一套框架的必要性。过程式的，缺乏有效的抽象 + 动态类型，闭包（作用域链），
全局作用域等 = 难理解，难预测追踪，难扩展。

__代码复用__

除了缺少抽象导致的代码难以理解、修改以外，另一个不良后果便是很难确定代码的作用范围。

举个现实中很常见的例子：PM往往会认为如果你网站上已经有了东西，那么在其他地方
使用这个东西（或实现类似的东西）并不会消耗程序员的时间，至少不会消耗太多。

然而实际上我在面对这一问题时，我多半会想：“当时我没觉得它会被复用，我可能要先花点
时间把它抽出来”。而“抽出来”便是要确定这个功能的作用范围，或者说我需要确定这部分代码
的依赖，和依赖这部分代码的代码，以保证我把这部分代码拿出来以后，这部分代码和其他代码
都不会因为未声明的变量和函数抛出错误。

__DOM操作__

看一眼我们的jQuery代码（或原生），不难发现我们绝大多数时候都是在“query DOM”（$(),或是getElement...）。
因为在改变DOM之前，我们首先要找出目标DOM。其本质问题在于DOM树的状态和javascript
（中的数据）的状态是分离的，即我们需要用“query”的方式去人工维护DOM树和javascript
的一致性。维护这两者一致的工作本身是不可避免的，问题是在代码量变大、代码变复杂的情况下，
这一工作的代价可能要比我们想象的要复杂的多$sidenote([Localytics的一篇blog中提到过这一点](http://www.csdn.net/article/2013-04-12/2814864-Localytics-AngularJS-Backbone))。

##对于这两个问题，React做了什么？

###树状结构
React要求每一个ReactClass的渲染方法中，都有且只有一个最外层的Virtual DOM，但它内部
（children属性）可以包含多个Virtual DOM。所以用React写的应用的结构是树状的$sidenote()。
React应用的树状结构使得任何一个ReactClass都只和它的外层ReactClass以及
子ReactClass进行直接交互，也即我们很容易弄清楚我们某一部分代码的作用范围。这就使得
我们在修改React的代码时会格外轻松。实际上这一点对于涉及到UI的代码来说是十分重要的，
因为我个人觉得通常在产品需求变化时，UI的变化经常会需要你不断地考虑是否要对代码做
抽象，分离出一部分公用的内容。而React会让你的每一部分代码都为复用做好准备。

###容易确定的数据流
大多数情况下，我们都可以通过改变应用中的数据来改变React应用的状态。很多时候我们在追踪
应用的状态时，实际上都是在追踪数据的变化。所以掌握数据的状态在维护及扩展时是非常重要的。
得益于前面所述的树状结构以及数据和视图的紧密贴合，React应用的数据流向十分清晰明。

除了这点，React应用中的每一部分都使用props和states两个属性来储存状态。
其中props属性是外部传入的，在ReactElement部不（应该）发生改变；
而state属性产生于ReactElement的内部，可传递到子ReactElement中作为props。
这两个属性很好地将控制components状态的数据进行了分类，让我们更容易在局部代码中的数据进行朔源。

###直接生成Virtual DOM来取代DOM操作
我们写的React代码并不直接操作DOM，而是根据当前的数据组织出一个Virtual DOM，然后由
Virtual DOM完成对DOM树的调节。

由于新生成的Virtual DOM会和上一次的Virtual DOM进行比对，
然后根据Virtual DOM之间的差别对DOM树进行最小的、必要的调节，所以这一做法在大多数
情况下都能够保证性能$sidenote。

而组织Virtual DOM来操作DOM的更大好处在于：你不需要
考虑将DOM树从当前的状态A变成目标状态B所需要进行的每一个DOM操作，而只要根据当前数据的
状态去组织一个目标状态B的Virtual DOM即可，所以这种做法节省了我们的很多工作。

另外值得一提的是，当我把组织Virtual DOM的过程当成是一种模板引擎，并于其他模板做对比时
，我发现Virtual DOM + jsx异常灵活。

##我没有选择Angular的原因
你可能容易在Angular和Ember之间做比较，但却很难将React与前面两者做比较。因为他们之间过于不同，以至于我把这篇文章的初衷都稍作了修改。所以这里更多从实践的角度谈谈我的看法，可能充满了个人偏见。

1. React的代码可预测行更强

把这个问题放到React，你会发现数据都放在props（外部传入）和state（本身拥有）上，部件在每个生命周期上要做的事情都有序地放置在componentWillMount、componentDidMount、componentDidUpdate等等的方法中（当然你不一定需要全都用到），涉及Virtual DOM的东西都在Render方法里，少量退回到原生（jquery）的DOM操作都可以通过refs属性找到。这样，当你们从React的角度来思考一个需求的实现时，你和你同事的思路一般不会相差太大。

说这是个问题，是因为我觉得适合生产环境上的框架应该单靠框架本身就能使团队中的每个人都对某一个功能的开发抱有相近的想法。这样代码就更容易预测。

，我觉得好的框架应该已经规定好了我们做一件事情的流程，不

2. MVC与View$sidenote()

我看到有些人评论React没有遵循MVC分割Model和View，加重了代码的耦合程度。

比如Angular的Controller和Directive可以分别被认为是MVC（或MVVM）中的Model和View。这就意味着你可以将一个component拆分开来，分别实现这两个部分，也让更小粒度的代码复用成为了可能。

但问题是明确地分割出Model和View可能在涉及复杂UI交互的领域并不是个最好的选择，更多的场景可能需要我们根据实际情况和需求进行思考选择。

然而问题在于：你需要考虑如何去组织这些代码，并决定一个Controller或Directive到底要涉及多少功能，才能用的顺手。Angular给我们提供了一套强大的工具，但你仍要去学习怎么用好它们。

对于React来说，由于React并不分割Model和View，并且代码非常容易被修改、扩展，所以你完全可以凭直觉来决定一个功能要如何实现，等待问题出现以后在进行修改。因为只要你的代码不是真的太糟糕的话，这一过程真的并不痛苦。

事实上，如果MVC的重点在于Seperation of Concern，那么React部件之间的作用范围分明本身就可以认为是这种思想的实践。$sidenote()。只要能解决问题，是不是MVC又有什么关系呢？

3. 开发效率很重要，但代码的可预测、可扩展性可能更加重要。

4. 学习曲线很重要，并且在你希望你的同事接纳他们不熟悉的东西，或是需要给你的上司看到成果时，时显得更加重要。虽然要用好React的话也需要学习不少东西，但这一过程会平滑的多得多。

5. Use Proofed Technology$sidenote()

除了Facebook和Instagram以外，看看[这里]()，你会发现 AirBnb, Uber, 
支付宝，天猫等公司、产品都在上面。不管这些大公司在他们的产品中到底使用了多少React，至少这些公司对React都持肯定态度。Angular虽然也同样声名远播，但却不至于如此。

##结论

1. React十分注重

##附：我们React一些实践结果

__Virtual DOM的性能问题__

相比于原生js直接修改DOM，Virtual DOM需要多做一次“生成Virtual DOM“和一次”Virtual DOM“的比对，
所以我在开发过程中一直很关注React的性能问题（这可能同时也是不少反对前端框架开发的工程师的
论点之一）。碰巧我们应用的某个页面中，有可能会出现数百张
卡片同时出现在页面中的情况。在我按照这之前的方式把这个页面从原生改为React以后，我发现一旦
数百张卡片出现，每次改变应用的状态（state）都会有2秒左右的卡顿。

于是我按照[React doc](https://facebook.github.io/react/docs/advanced-performance.html)的教程来
来尝试优化这个页面。这个教程上优化的要点实际上只有两点：

1. 使用[PureRenderMixin]()，或是`componentShouldUpdate`阶段在不必要的情况下返回false。

2. 在第一点的基础上，使用[Immutablejs]()，来使得在数据结构比较复杂的情况下（Array, Object），
我们可以只比较reference的变化就判断component是否应该重新渲染。相当于减轻了比对过程的消耗，
同时也避免了一些本不必要的视图更新。

这两个方法中我采用了前一个，我没有使用Immutablejs，但我用了React自带的[Immutable Helper]()来
达到相似的效果。

其结果是，问题并没有得到很好的改善。因为即便我避免了额外的Virtual DOM的生成、比对过程，但我们
的应用在状态发生改变时，仍会同时进行数百次对”是否要生成Virtual DOM并进行比对“的判断。

那么这个问题是否无法解决了呢？答案是否定的。我最后跳过了比对过程，直接利用`refs`和卡片中
事先定义好的方法来直接改变目标卡片的状态。这实际上就是退回到了原生实现。结果令人我满意。

所以我现在对React性能的看法是：__绝大多数情况下没有问题，有问题的话也可以退回原生__。

__代码量的变化__

代码越少，问题越少。在刚开始写Angular代码时，我印象深刻的一点是，你觉得自己的代码刚写
到一半，就突然发现你的功能已经基本完成了。我觉得。

那么对比原生，React的代码量会有什么变化呢？在我们的应用中，我正好有大量的机会来将原声代码
该写成React代码。根据我的观察，我们应用的React版本和原生的版本代码量（行数）差别不大。
有时React甚至会稍多一些。

__能否从原生（jquery）平滑迁移到React？__
可以，我们正在做。你可能需要看看文档，结合实际情况多思考一下怎么做比较合适。

__在用React进行了一段时间的实践以后我最大的主观感受__
我不再那么害怕我以前的代码和我同事的代码了。
