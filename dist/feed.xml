<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[oyyd]]></title>
        <description><![CDATA[oyyd]]></description>
        <link>https://blog.oyyd.net</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Fri, 20 May 2016 13:28:37 GMT</lastBuildDate>
        <atom:link href="https://blog.oyyd.netdist/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[推荐React.js Conf 2016中的一些精彩演讲]]></title>
            <description><![CDATA[<h1 id="-react-js-conf-2016-">推荐React.js Conf 2016中的一些精彩演讲</h1>
<p><strong>前言：</strong> 在会前，twitter上出现了这样的对话...</p>
<p><img src="/static/posts/react-conf-2016/before-everything.png" alt="Before everything"></p>
<p>所以你可以预料到今年会上没有特别爆炸性的项目出现，并且关于React Native的话题有很多。我觉得今年话题的核心还是集中于React Native，我也会在这上面啰嗦一些我的想法。</p>
<p>下面我会推荐一些我觉得比较精彩、比较有价值的演讲（由于时间有限我并没有去看lightning talk）。</p>
<h2 id="react-native-">React Native相关演讲</h2>
<h3 id="-nick-schrock-keynote-https-www-youtube-com-watch-v-mgukhcnrqga-"><a href="https://www.youtube.com/watch?v=MGuKhcnrqGA">Nick Schrock - Keynote</a></h3>
<p>Nick做了今年的开场演讲，而且演讲风格非常逗趣。并且Nick在Facebook的7年中从未写过太多JavaScript，却被选作React会议开场的演讲者。说到这里估计你多多少少也会提起了些兴趣。</p>
<p>Nick的演讲大部分内容主要集中于React Native，他以一个非JavaScript开发者的角度去阐述了React Native所可能带来的价值，我们可以从中提取出这样的观点：</p>
<ul>
<li>React Native并不是跨平台的，但我们却可以在平台之间共用大量代码（Facebook用React Native开发的两款App共享了约85% - 90%的代码）</li>
<li>React Native从设计上就发挥了多核的优势</li>
<li>用React Native开发应用（大部分时间）不需要重编译，开发效率高</li>
<li>React Native的代码可以在线更新，避免一些不必要的硬发布流程</li>
<li>用React Native开发应用只需要一个统一的团队</li>
</ul>
<p>当然Nick更多的是在阐述React Native的优点，这些我们多多少少也已经知道了。但如果React Native已经足够优秀的话，那我们应该能在过去的一年里看到更多用React Native开发的应用。这里我从阐述一些我认为的React Native <strong>目前</strong> 的劣势及容易误解的地方：</p>
<ul>
<li><p>React Native目前还不够成熟。目前React Native基本上一个月会发release两次，并且Android开发的体验还比不上iOS。</p>
</li>
<li><p>因为React Native的应用还不够广泛，这就意味着相关社区及相关开源项目的支持力度还不够。你碰到一个问题可能会很难google出有效的回答，同时你们也很难靠自己的力量去修复React Native中出现的bug（你们的团队需要同时充分掌握多门语言）。</p>
</li>
<li><p>在不同平台上共享的代码越多，可能意味着我们越没有充分发挥平台的优势和特点（主要是对UI／UE而言）。</p>
</li>
<li><p>React Native的开发既不同于Web开发也不同于Native开发，这意味着你目前很难从市场上找到有经验的人。</p>
</li>
<li><p>虽然你们React Native的项目主要需要的是JavaScript开发者，但如果你们想利用React Native开发一款用户体验至上的应用的话，你们还是需要有Android和iOS的开发者作支持（或是JavaScript开发人员也要有一定的Native经验），以便在一个需求不能够通过纯JavaScript的方案解决的时候能退回到Native的解决方案（主要是写一些桥接JavaScript和Native的代码，并不一定需要完全用Native来解决，并且如果社区支持能越来越给力的话，我们需要的Native支持也会越来越少）。</p>
</li>
</ul>
<p>那么是否现在用React Native来开发用于生产环境的App是不是不切实际的呢？从一些公司的实践结果来说是否定的，这里强烈推荐加下来James Ide关于在实践环境中运用React Native的演讲。</p>
<h3 id="-james-ide-https-youtu-be-2zthnq-hixa-list-plb0iamt7-gs0m8q95ric2lom6nc77q1iy-"><a href="https://youtu.be/2Zthnq-hIXA?list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY">James Ide - 团队 × 技术</a></h3>
<p>James在Exponent公司里亲历了React Native团队的建设和开发。James本人的工作经历足以证明他是一个优秀的工程师，所以他的演讲和对React Native的看法和经验也是极具参考价值的。</p>
<p>这里另一款强烈推荐的，用React Native开发的优秀的App是Discord。Discord所有的客户端（Web、Mobile、Desktop）都是用JavaScript（React）开发的，并且用户体验极佳。</p>
<h3 id="-parashuram-n-web-https-www-youtube-com-watch-v-b8j8xn3plpk-"><a href="https://www.youtube.com/watch?v=B8J8xn3pLpk">Parashuram N - 在原生应用上发挥Web的发布能力</a></h3>
<p>React Native上非常有价值的一个特性是在线更新代码，而Parashuram是有效拓展这一特性的<a href="https://github.com/Microsoft/react-native-code-push">codepush</a>项目的作者。他给我们介绍了如何利用这一工具来发挥React Native的发布能力。</p>
<p>除此之外，Parashuram是微软的员工，他还给我们演示了如何利用visual studio code相关插件简化React Native开发。虽然看起来参加会议的观众大多不使用vscode，有点尴尬，但我本人是非常希望Atom上有类似的、稳定的插件。</p>
<h2 id="better-react">Better React</h2>
<h3 id="-steve-mcguire-https-www-youtube-com-watch-v-kdarp5qz6nu-list-plb0iamt7-gs0m8q95ric2lom6nc77q1iy-index-28-"><a href="https://www.youtube.com/watch?v=kDARP5QZ6nU&amp;list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY&amp;index=28">Steve McGuire - 对性能上的妥协说不</a></h3>
<p>如果你真的在React开发过程中碰到了性能问题，或是项目本身对性能要求非常苛刻，你们又希望使用React，又或是希望在提高React应用的性能上寻找新思路的话，那我强烈推荐观看本视频。</p>
<p>Steve是Netflix的员工，演讲中他介绍了他们是如何在便宜的30美元的设备上，一步步将用户的输入和应用的响应渲染时间压缩到100ms以内。他们的优化无所不用，对，无所不用。</p>
<h3 id="-lin-clark-https-www-youtube-com-watch-v-wiqbzhdepvm-jared-forsyth-redux-re-frame-relay-om-next-https-www-youtube-com-watch-v-jwq3sgoixg-list-plb0iamt7-gs0m8q95ric2lom6nc77q1iy-index-22-"><a href="https://www.youtube.com/watch?v=WIqbzHdEPVM">Lin Clark - 以卡通的形式介绍数据处理</a>及<a href="https://www.youtube.com/watch?v=-jwQ3sGoiXg&amp;list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY&amp;index=22">Jared Forsyth - Redux, Re-frame, Relay, Om/next, 天啊!</a></h3>
<p>Lin以漫画的形式介绍了React上的几个专注于数据处理的框架的思想和异同，而Jared责对有React衍生出的，以及与React持有相同核心思想的框架做了介绍和对比。</p>
<p>这里还强烈推荐James Long关于Redux的一个<a href="https://www.youtube.com/watch?v=BfzjuhX4wJ0">视频</a>，从中你可能会明白为什么不少人会认为Redux是React社区在2015年中的最佳产物。</p>
<h3 id="-ben-alpert-https-www-youtube-com-watch-v-rjf2jyzs8a-"><a href="https://www.youtube.com/watch?v=-RJf2jYzs8A">Ben Alpert - 我们前方还有什么</a></h3>
<p>Ben介绍了很多当前React体系的不足或是可以改进的地方。</p>
<h2 id="-">其他演讲</h2>
<p>除了上面这些两大类内容之外，也有不少有意思的演讲：</p>
<h3 id="-jamison-dance-rethinking-all-practices-elm-https-www-youtube-com-watch-v-txxkx_i39a8-index-31-list-plb0iamt7-gs0m8q95ric2lom6nc77q1iy-"><a href="https://www.youtube.com/watch?v=txxKx_I39a8&amp;index=31&amp;list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY">Jamison Dance - Rethinking All Practices: 用Elm构建应用</a></h3>
<p>你可能跟我一样从未用过Elm，但却经常看到别人谈论Elm。通过这个视频即便我们没有用过Elm也能够了解其中的一些秘密。</p>
<p>如果你连视频也不想看的话，我也有一个更简单粗暴的解释：React ＋ Redux + FRP上的优秀的特性加起来等于Elm。</p>
<p>这个视频同时也是<a href="https://github.com/gaearon">gaearon</a>极力推荐的。</p>
<h3 id="-syrus-akbary-js-graphql-https-www-youtube-com-watch-v-rnoypsrqyps-list-plb0iamt7-gs0m8q95ric2lom6nc77q1iy-index-29-"><a href="https://www.youtube.com/watch?v=RNoyPSrQyPs&amp;list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY&amp;index=29">Syrus Akbary - 非JS服务器上的GraphQL框架</a></h3>
<p>这里Syrus指的是python上的GraphQL实现<a href="https://github.com/graphql-python/graphene">graphene</a>。关于GraphQL要解决的问题和好处也可以选择去看GraphQL的官方文档。</p>
<p>Syrus在GraphQL的实践过程中提出来的一点想法我觉得从另一个角度体现了GraphQL可以给我们带来的好处：服务器端不应该去具体知道客户端到底需要什么结构的数据，客户端的开发人员应该可以自己写query拿自己想要的数据及结构，这样他也就不用在需求变更的时候跑去问后端开发工程师去修改或提供API，从而造成更多的代码发生变动。GraphQL优化了我们开发的流程。</p>
<h3 id="-helena-milosevic-https-www-youtube-com-watch-v-n233t0epwts-list-plb0iamt7-gs0m8q95ric2lom6nc77q1iy-index-5-"><a href="https://www.youtube.com/watch?v=N233T0epWTs&amp;list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY&amp;index=5">Helena Milosevic - 揭开技术招聘流程的面纱</a></h3>
<p>Helena是Facebook的HR，你没看错，这确实由HR进行的一次演讲。Helena想我们介绍了Facebook招聘技术岗位员工时的基本流程，事实上大体流程和国内的大公司进行的招聘流程还是非常相似的，比较特别的是有一个需要应聘者在白板上和面试官进行交流的环节。仔细想一下这个流程我觉得还是非常有意义的，因为应聘者在白板上阐述自己想法的过程会不仅考验他的专业知识，同时也体现了他和其它员工进行分享和讨论的能力。本身这类事情也是现实工作中非常有可能会出现的环节，是非常贴合实际的。</p>
<p>最后Helena还分享了一句非常在理的话：</p>
<p>Do or do not. Never try.</p>
<p>与诸君共勉。</p>
]]></description>
            <link>https://blog.oyyd.net/post/reactjs_conf_2016_recommendation</link>
            <guid isPermaLink="false">bfc9fbb201d93e59bdb7bf40f225783a</guid>
            <pubDate>Tue, 15 Mar 2016 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[使用webpack分割代码的思路]]></title>
            <description><![CDATA[<h1 id="-webpack-">使用webpack分割代码的思路</h1>
<p>2016年01月18日</p>
<p><strong>前言：</strong></p>
<p>可能你跟我一样最开始只是把webpack作为打包的工具，把所有的东西都打包进一个bundle.js文件供我们的应用使用。这种做法不仅简单、利于缓存，更重要的它可以使得我们的JavaScript代码更像是其他的编程语言那样运作，而不用为模块和加载的问题操心太多。但随着代码的不断增长，需要加载的代码会不断增加，并且当我们期望某些页面在移动设备上（app或浏览器）运行时，非wifi的网络环境会使得资源加载时间显得更加不可接受。</p>
<p>好在webpack是个非常强大且扩展性极强的工具，它提供了一些强大的特性来帮助我们解决这一问题。</p>
<h2 id="-">基本原则</h2>
<p>事实上把所有的js文件打包成一个文件是一种极端做法，而按需加载每一个JavaScript文件则是另一种极端做法。这两种做法并没有绝对的优劣，这里我们需要做的事情是在这两个极端之间找到一个相对可以接受的做法。</p>
<p>如果你希望了解得更多的话，可以参考链接中的这篇文章。这篇文章很好地讲述了汗学院面对这一困境的思路：
<a href="http://jamie-wong.com/2014/11/29/the-js-packaging-problem/">The JavaScript Packaging Problem</a></p>
<p>而从缓存、压缩比、请求次数等角度来看，我认为打包的方式是整体优于按需加载的，即“多加载代码”总是整体优于“按需加载代码”。这也是下文做法的依据。</p>
<h2 id="-webpack-">在webpack上我们可以利用的工具</h2>
<p>webpack主要支持两种代码分割方式，一是在应用的代码中设置split points，另一种则是在是在webpack的配置文件中设置代码块。</p>
<h3 id="split-points">split points</h3>
<p>split points会告知webpack代码的分割位置，webpack依次设置代码块(chunk)，并在运行环境中由webpack自动加载代码块：</p>
<pre><code class="lang-js">// 这样的模块会被webpack打包在同一个代码块中，
// 所以我们总是能保证代码已经存在
var _ = require(&#39;lodash&#39;)

// 利用ensure和require来动态加载代码
require.ensure([], function(require) {
  let contacts = require(&#39;./contacts&#39;)
})
</code></pre>
<p>实际上<code>require.ensure</code>这种方式有些像requirejs或其他浏览器上的模块加载库。webpack可以根据split points来将多个文件自动打包成一个代码块（chunk），并在运行时（比如浏览器上）自动加载依赖的代码块。因为是以代码块为单位，而不像其他库一样是以单个JavaScript文件为单位，所以相比于传统的模块相关的库来说，webpack可以帮我们做很多优化。</p>
<p>但值得注意的是，<code>require.ensure</code>并不是真正的动态加载，虽然同样是在运行中加载依赖，但webpack会加载所有的依赖<sup id="1" class="margin-toggle sidenote-number">1</sup><span for="1" class="mdl-tooltip sidenote">也有特别的情况，比如在<code>if</code>语句中，如果条件为<code>false</code>，则代码体中的<code>require</code>就不会被执行</span> ，比如在下面的代码中：</p>
<pre><code class="lang-js">require.ensure([], function(require) {
  var shouldLoad = false;
  if (shouldLoad) {
    // 虽然这块代码不会被真正执行，但webpack还是会事先加载这一模块
    let contacts = require(&#39;./contacts&#39;)
  }
})
</code></pre>
<p>虽然这<code>if</code>中的代码不会被真正执行，但webpack还是会事先加载这一模块。</p>
<p>我个人不喜欢这种做法，因为相比于后面在配置中进行的代码分割的方式来说，它实际上在代码中引入了另一种机制来加载模块，代码及加载状态会变得更加复杂。但这种做法把代码的分割加载工作都交给了webpack，充分利用它能省下不少工作，所以充分利用这一特性也是一种选择。</p>
<h3 id="-">通过配置文件分割代码</h3>
<p>另一种方式是在webpack的config文件中配置代码块。单纯配置入口文件的话，webpack会将入口文件所涉及的所有文件都打包到一个文件里面。但这也意味着两个入口文件所生成的代码块之间会有很多重复的部分，并且完全不能利用浏览器的缓存机制。比如你的两个入口文件都用了react，那打包出来的两份文件都会有react，没办法交叉利用。</p>
<p>为了解决这一问题，webpack提供了插件<code>CommonsChunkPlugin</code>来帮助我们自动抽取出代码块中相同的部分：</p>
<pre><code class="lang-js">var path = require(&quot;path&quot;);
var CommonsChunkPlugin = require(&quot;../../lib/optimize/CommonsChunkPlugin&quot;);
module.exports = {
    entry: {
        pageA: &quot;./pageA&quot;,
        pageB: &quot;./pageB&quot;,
        pageC: &quot;./pageC&quot;,
        adminPageA: &quot;./adminPageA&quot;,
        adminPageB: &quot;./adminPageB&quot;,
        adminPageC: &quot;./adminPageC&quot;,
    },
    output: {
        path: path.join(__dirname, &quot;js&quot;),
        filename: &quot;[name].js&quot;
    },
    plugins: [
        //将adminPageA和adminPageB中相同的依赖打包到admin-commons.js文件中
        new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;adminPageA&quot;, &quot;adminPageB&quot;]),
        //将pageA、pageA和admin-commons.js中相同的、并且至少被两个chunk使用的依赖打包到commons.js文件中
        //注意这里显示出CommonsChunkPlugin生成的chunk也可作为参数传入
        new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;pageA&quot;, &quot;pageA&quot;, &quot;admin-commons.js&quot;], 2),
        //将pageC和adminPageC中相同的依赖打包到c-commons.js文件中
        new CommonsChunkPlugin(&quot;c-commons.js&quot;, [&quot;pageC&quot;, &quot;adminPageC&quot;]),
    ]
}
</code></pre>
<p>然后我们只要在HTML文件中依次引入代码块即可：</p>
<pre><code class="lang-html">&lt;!--pageA.html--&gt;
&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;js/commons.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;js/pageA.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="lang-html">&lt;!--adminPageA.html--&gt;
&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;js/commons.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;js/admin-commons.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;js/adminPageA.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这样，<code>commons.js</code>和<code>admin-commons.js</code>就能够有效地被浏览器缓存了。</p>
<p>特别值得注意的是，<code>CommonsChunkPlugin</code>甚至提供了<code>minChunks</code>和<code>minSize</code>这两个配置来筛选文件，从而调节入口文件（entry）所打包成的文件和通用代码块（commons chunk）之间的大小配比。<code>minChunks</code>和<code>minSize</code>越小，则commons chunk文件则越大，代码被缓存的几率越大，加载的冗余代码也更多；反之commons chunck文件则越小，代码被缓存的几率越小，但加载的冗余代码也更少。</p>
<p>通过编写入口文件我们可以将所有可能被用到的文件打包成一个文件，而通过利用<code>CommonsChunkPlugin</code>，我们可以有效地缓存不同入口文件之间重叠的代码，特别是对非单页应用而言，这点非常重要。这种方式分割的代码不会像split points那样会自动加载，我们需要按照依赖依次引入分割而成的文件。</p>
<h2 id="-">简单的代码分割思路</h2>
<p>首先把所有页面100%会被使用的文件分割出来，即打包成vendor文件。这类文件主要是外部依赖，比如：React、jQuery这样的framework，或是momentjs等经常会用到的代码库。</p>
<p>然后再为需要严格控制js文件大小的页面编写独立的入口文件，比如运行在移动设备上的活动页面。独立的入口文件会保证打包出来的文件没有（太多）冗余。</p>
<p>对于其他没有那么严格的要求的页面来说，我们可以从整体按照某一套规则来分割代码。比如前面链接中的汗学院把代码分割成了：<code>core-package.js</code>，<code>content-package.js</code>，<code>homepage-package.js</code>。</p>
<p>问题是通过配置打包成的文件需要我们手动管理依赖，即按照依赖关系在页面中依次引入script标签，这种做法在依赖十分复杂的情况下是不可接受的。那这时候通过<code>require.ensure</code>来帮助我们管理依赖或许是个不错的主意。</p>
]]></description>
            <link>https://blog.oyyd.net/post/how_to_split_your_code_in_webpack</link>
            <guid isPermaLink="false">89b1ca0a33a279b425951b43ee4081db</guid>
            <pubDate>Sun, 17 Jan 2016 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究JavaScript上的编译器 —— nunjucks]]></title>
            <description><![CDATA[<h1 id="-javascript-nunjucks">探究JavaScript上的编译器 —— nunjucks</h1>
<p>2016年01月12日</p>
<h2 id="-">写在前面的实践结果</h2>
<p>在前面<a href="https://blog.oyyd.net/post/javascript_compiler_marked">marked的学习过程</a>中，我简单地hack了marked来绑定了chartjs。但对于<a href="https://github.com/mozilla/nunjucks">nunjucks</a>，我没有想到比较好的实践方式。所以这次我将帮助修复nunjucks上的一些bug来作为本次实践。</p>
<p>到目前为止，已尝试修复的问题有：<a href="https://github.com/mozilla/nunjucks/pull/634">#571</a>, <a href="https://github.com/mozilla/nunjucks/pull/632">#332</a>, <a href="https://github.com/mozilla/nunjucks/pull/631">#595</a>, <a href="https://github.com/mozilla/nunjucks/pull/628">#612</a>, <a href="https://github.com/mozilla/nunjucks/pull/339">#317</a></p>
<p><strong>补充：</strong> 后来我又修复了不少bug，也让@carljm给我collaborator的权利，但现在反而更想做自己的项目而没心思花时间在上面了。</p>
<h2 id="nunjucks-">nunjucks的代码结构</h2>
<p>nunjucks的整体代码结构如下：</p>
<p><img src="/static/posts/javascript-compiler/nunjucks.png" alt="nunjucks"></p>
<p>接下来再让我们看看每一部分的作用。</p>
<h3 id="lexer">Lexer</h3>
<p>Lexer中最主要的类被命名为Tokenizer，这听起来与Scanner异曲同工。</p>
<p>模板引擎的模板代码可以很容易地被分为成两种，一种将直接用于输出（即Lexer生成的TOKEN_DATA），另一种则可能有复杂的逻辑于其中。nunjucks在Lexer中有一个in_code属性用于储存当前的解析状态，并依次进行两套不同的解析规则。</p>
<p>下面展示了一段模板所生成的tokens：</p>
<pre><code class="lang-js">nunjucks.renderString(&#39;&lt;h1&gt; Hello, {{ me }}! &lt;/h1&gt;&#39;, { me: &#39;oyyd&#39; })

// 生成的tokens:
// { type: &#39;data&#39;, value: &#39;&lt;h1&gt; Hello, &#39;, lineno: 0, colno: 0 }
// { type: &#39;variable-start&#39;, value: &#39;{{&#39;, lineno: 0, colno: 12 }
// { type: &#39;whitespace&#39;, value: &#39; &#39;, lineno: 0, colno: 12 }
// { type: &#39;symbol&#39;, value: &#39;me&#39;, lineno: 0, colno: 13 }
// { type: &#39;whitespace&#39;, value: &#39; &#39;, lineno: 0, colno: 15 }
// { type: &#39;variable-end&#39;, value: &#39;}}&#39;, lineno: 0, colno: 16 }
// { type: &#39;data&#39;, value: &#39;! &lt;/h1&gt;&#39;, lineno: 0, colno: 16 }
</code></pre>
<p>Tokenizer只是将源码转换成tokens供其它代码使用。Tokenizer碰到什么字符就会试着把它转换成token，它不会参与任何高层次的逻辑，比如不会检查“{{”和“}}”是否配对。这一检查实际上是在Parser中进行的。</p>
<h3 id="parser">Parser</h3>
<p>Parser实际上是对tokens进行处理，以保证代码的语法规则合法，并据此生成由node组成的AST。</p>
<p>比如当出现“{{”时（TOKEN_BLOCK_START），Parser就会尝试在剩余的tokens中寻找“}}”（TOKEN_BLOCK_END）。如果没有找到，则Parser会认为代码不符合语法规则，从而抛出异常。</p>
<p>这里非常值得一提的是AST的生成方式。我们先来看看nunjucks尝试解析<code>or</code>的方法，注意代码中的注释：</p>
<pre><code class="lang-js">// ...
parseOr: function() {
    var node = this.parseAnd(); // 注意这里
    while(this.skipSymbol(&#39;or&#39;)) {
        var node2 = this.parseAnd(); // 注意这里
        node = new nodes.Or(node.lineno,
                            node.colno,
                            node,
                            node2);
    }
    return node;
},
// ...
</code></pre>
<p>我们可以看出在解析<code>or</code>之前，Parser首先会尝试解析<code>and</code>。而尝试解析<code>and</code>的代码如下：</p>
<pre><code class="lang-js">// ...
parseAnd: function() {
    var node = this.parseNot(); // 注意这里
    while(this.skipSymbol(&#39;and&#39;)) {
        var node2 = this.parseNot(); // 注意这里
        node = new nodes.And(node.lineno,
                             node.colno,
                             node,
                             node2);
    }
    return node;
},
// ...
</code></pre>
<p>和而如果你去看Parser尝试解析<code>not</code>的代码则会发现<code>parseNot</code>又会尝试先去解析其他语法。仔细思考一下<code>or</code>、<code>and</code>和<code>not</code>的关系你会发现他们是按照自己在语法中的优先级先后进行的，即Parser会优先尝试寻找高优先级的语法标识。并且对于AST来说，通常高优先级的语法只会是低优先级语法的子孙节点，比如对于：</p>
<pre><code class="lang-js">a and b or c
</code></pre>
<p>它的AST中<code>and</code>会是<code>or</code>的左子节点，即便调换他们的位置:</p>
<pre><code class="lang-js">a or b and c
</code></pre>
<p><code>and</code>仍旧是<code>or</code>的子节点，只不过变成了右子节点。</p>
<p>通过这样的做法，Parser将所有的tokens整合成了一棵树，而这棵树的根节点是全局只应有一个的<code>Root</code>。</p>
<p>如果你有兴趣了解得更仔细的话，可以看看下面的这个由Parser生成的AST。下面的模板代码：</p>
<pre><code class="lang-html">&lt;p&gt;
  Hi, I&#39;m
  {%if name and isNameValid or forceShowName%}
    &lt;span&gt;{{name}}&lt;/span&gt;
  {%endif%}
&lt;/p&gt;
</code></pre>
<p>生成的AST如下（注释为节点类型）：</p>
<pre><code class="lang-js">{ parent: undefined, // Root
  lineno: 0,
  colno: 0,
  children:
   [ { parent: undefined, // Output
       lineno: 0,
       colno: 0,
       children:
        [ { lineno: 0, colno: 0, value: &#39;&lt;p&gt;\n  Hi, I\&#39;m\n  &#39; }, // TemplateData
          [length]: 1 ] },
     { lineno: 2, // If
       colno: 2,
       cond:
        { lineno: 2, // Or
          colno: 5,
          left:
           { lineno: 2, // and
             colno: 5,
             left: { lineno: 2, colno: 5, value: &#39;name&#39; }, // Symbol
             right: { lineno: 2, colno: 14, value: &#39;isNameValid&#39; } }, // Symbol
          right: { lineno: 2, colno: 29, value: &#39;forceShowName&#39; } }, // Symbol
       body:
        { parent: undefined, // NodeList
          lineno: 0,
          colno: 0,
          children:
           [ { parent: undefined, // Output
               lineno: 2,
               colno: 42,
               children: [ { lineno: 2, colno: 42, value: &#39;\n    &lt;span&gt;&#39; }, [length]: 1 ] }, // TemplateData
             { parent: undefined, // Output
               lineno: 3,
               colno: 10,
               children: [ { lineno: 3, colno: 10, value: &#39;name&#39; }, [length]: 1] }, // Symbol
             { parent: undefined, // Output
               lineno: 3,
               colno: 14,
               children: [ { lineno: 3, colno: 14, value: &#39;&lt;/span&gt;\n  &#39; }, [length]: 1 ] }, // TemplateData
             [length]: 3 ] },
       else_: null },
     { parent: undefined, // Output
       lineno: 4,
       colno: 7,
       children: [ { lineno: 4, colno: 7, value: &#39;\n&lt;/p&gt;&#39; }, [length]: 1 ] }, // TemplateData
     [length]: 3 ] }
</code></pre>
<h3 id="compiler">Compiler</h3>
<p>Compiler使用AST生成中间代码。nunjucks运行在node上，所以nunjucks生成的中间代码自然就是JavaScript代码，这也意味着nunjucks可以运行在浏览器上。</p>
<p>AST中的nodes会被用来生成JavaScript代码片段，上文Parser中的那段模板代码生成的中间代码如下:</p>
<pre><code class="lang-js">function root(env, context, frame, runtime, cb) {
  var lineno = null;
  var colno = null;
  var output = &quot;&quot;;
  try {
    var parentTemplate = null;
    output += &quot;&lt;p&gt;\n  Hi, I&#39;m\n  &quot;;
    if (runtime.contextOrFrameLookup(context, frame, &quot;forceShowName&quot;) || runtime.contextOrFrameLookup(context, frame, &quot;name&quot;) &amp;&amp; runtime.contextOrFrameLookup(context, frame, &quot;isNameValid&quot;)) {
      output += &quot;\n    &lt;span&gt;&quot;;
      output += runtime.suppressValue(runtime.contextOrFrameLookup(context, frame, &quot;name&quot;), env.opts.autoescape);
      output += &quot;&lt;/span&gt;\n  &quot;;;
    }
    output += &quot;\n&lt;/p&gt;&quot;;
    if (parentTemplate) {
      parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);
    } else {
      cb(null, output);
    };
  } catch (e) {
    cb(runtime.handleError(e, lineno, colno));
  }
}
return {
  root: root
};
</code></pre>
<p>在Environment中，中间代码被作为函数体用来生成一个函数：</p>
<pre><code class="lang-js">var props = new Function(
  codeString // 中间代码
);
</code></pre>
<p>并且中间代码生成的函数将是个纯函数，传入同样的参数给它会得到同样的结果，这也就意味着在nunjucks中，编译的结果（到Compiler这一步的结果）可以被缓存起来，供以后直接使用，而不需要每次都进行编译。保存完编译结果以后以后，我们就不再需要模板了，而可以直接使用编译结果以提高性能并缩小浏览器上nunjucks文件的大小（即使用nunjucks-slim.js<sup id="1" class="margin-toggle sidenote-number">1</sup><span for="1" class="mdl-tooltip sidenote">现在这个时间点nunjucks.min.js文件大小为69KB,nunjucks-slim.min.js大小为24KB</span> ）。这就是nunjucks中的precompile特性，也是提高模板引擎性能的关键。</p>
<h3 id="context-environment-template">Context &amp;&amp; Environment &amp;&amp; Template</h3>
<p>到目前为止，有了中间代码以后，我们只要传入参数就可以生成目标代码(HTML)了。而从外部传入的参数分为两种，上下文环境（渲染过程中直接使用到的变量等）储存在Context中，而配置等参数将被储存在Environment中。而Template最主要的目的则是组合使用Environment，其作用可以简单地理解为：</p>
<pre><code class="lang-js">return root( // root为中间代码生成的函数
  ctx, // 上下文环境
  env // 配置等
);
</code></pre>
<p>nunjucks提供给开发者的api和配置的相关代码大多应该可以在这里找到。</p>
<p>至此主要的编译过程也就结束了。</p>
<h2 id="-">其他</h2>
<p>事实上nunjucks还有不少高级特性值得探讨，比如async（transformer.js），它会改变parser的结构。这些内容就留待以后再探讨吧。</p>
]]></description>
            <link>https://blog.oyyd.net/post/javascript_compiler_nunjucks</link>
            <guid isPermaLink="false">a2c9ce9544918e833018f3c6ee9f6ab9</guid>
            <pubDate>Mon, 11 Jan 2016 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究JavaScript上的编译器 —— marked]]></title>
            <description><![CDATA[<h1 id="-javascript-marked">探究JavaScript上的编译器 —— marked</h1>
<p><strong>前言：</strong></p>
<p>如果你也用google去搜过编译相关的话题的话，会发现很难找到适合入门的内容。但与之相对的是，很多的库和特性的实现都离不开编译这一流程，我们去看一些开源的JavaScript代码时也经常会看到Lexer，Parser，Compiler，AST等东西。如果没有相关知识，那看这些代码时经常会一头雾水。</p>
<p>实际上在学习这部分内容时，可能阅读书籍(<a href="http://www.amazon.com/dp/0321486811/?tag=stackoverfl08-20">编译原理</a>)是最合适的。因为编译的原理基本相近，也没有随时间推移而发生大的改变，经典的书籍依旧非常适用，但这里将尝试通过一些开源项目的代码来学习编译。虽然这种学习方式可能不够详尽，容易遗漏内容，但它也更有利于我们学习到开发实践中常用的编译（它们的代码结构通常会更加简单），以及了解不同环境下的编译过程的设计。</p>
<p>但这个话题本身涉及的范围较广，内容较深，所以对这些内容的学习将通三个项目的源码进行，它们分别是：<a href="https://github.com/chjj/marked">marked</a> —— 它将markdown文本转换成可供浏览器使用的HTML标签, <a href="https://github.com/mozilla/nunjucks/">nunjucks</a> —— 模板引擎和<a href="http://zaach.github.io/jison/">Jison</a> —— 一个通用的parser生成器，三部分进行。</p>
<p>那这次让我们从marked开始。</p>
<h2 id="-">基础理论：一个编译器的结构</h2>
<p>首先还是让我们通过来粗略了解一下编译器的通用结构（摘自编译原理）：</p>
<ol>
<li><p>Lexical Analysis/Scanning（词法分析），在marked中由Lexer实现。</p>
</li>
<li><p>Syntax Analysis/Parsing（语法分析），在marked中由Parser实现。</p>
</li>
<li><p>Semantic Analysis（语义分析），代码优化，在marked中没有实现。</p>
</li>
<li><p>代码生成，在marked中由Parser和Renderer实现。</p>
</li>
</ol>
<h2 id="marked-">marked中的代码结构</h2>
<p>marked的目的是根据输入的markdown文本来输出可供浏览器解析的HTML内容，藉由：</p>
<pre><code class="lang-markdown"># 探究JavaScript上的编译器 —— marked

编译这个话题在JavaScript上很少出现...
</code></pre>
<p>生成类似这样的代码：</p>
<pre><code class="lang-html">&lt;h1&gt;探究JavaScript上的编译器 —— marked&lt;/h1&gt;
&lt;p&gt;
  编译这个话题在JavaScript上很少出现...
&lt;/p&gt;
</code></pre>
<p>编译目标的不同会直接使得我们代码结构大相径庭。所以对任何编译相关的代码，时刻明确我们的设计的目的可以很好地帮助我们理解代码。</p>
<p>marked由四部分组成，分别是: Lexer、InlineLexer、Parser、Renderer。</p>
<p><img src="/static/posts/javascript-compiler/marked_composition.png" alt="marked-composition"></p>
<p>其中Lexer会处理最原始的文本，它将文本处理、抽象，提供tokens供Parser使用；Renderer提供一组api供Parser和InlineLexer调用，以生成HTML；而Parser将对Lexer提供的tokens进行进一步处理，并据此调用Renderer中的api生成最终的HTML字符串。</p>
<h3 id="lexer">Lexer</h3>
<p>Lexer用来将源码转换成tokens供Parser使用，其表现如下：</p>
<pre><code class="lang-js">const tokens = marked.Lexer.lex(&#39;# title&#39;);

// tokens:  
// [ { type: &#39;heading&#39;, depth: 1, text: &#39;title&#39; } ]
</code></pre>
<p>Lexer生成的tokens事实上只是对源码的抽象和描述。通常tokens都会有一个属性来描述其“类型”（上面生成的tokens中的“type”属性），并有可能有一个或多个“值”属性来描述具体信息（上面tokens中的“title”和“title”属性）。</p>
<h3 id="inlinelexer">InlineLexer</h3>
<p>marked中还有InlineLexer，从名称上看我们可以猜测它的整体作用和Lexer相近。但InlineLexer是有两点不同：一是InlineLexer只用于处理诸如：<code>__strong__</code>、<code>~~line-through~~</code>这样的内联文本；二是InlineLexer不返回tokens给Parser使用，它会直接利用Renderer将源码转换成HTML内容。</p>
<pre><code class="lang-js">const output = marked.InlineLexer.output(&#39;__strong content__&#39;, {}, {});
// output: &#39;&lt;strong&gt;strong content&lt;/strong&gt;&#39;
</code></pre>
<p>所以Parser在处理内联文本时，是直接使用InlineLexer生成结果，而不是像Lexer一样依据tokens用Renderers生成HTML。</p>
<h3 id="renderer">Renderer</h3>
<p>在Parser之前，我们先来看看Renderer的表现。我们可以直接使用Renderer生成HTML:</p>
<pre><code class="lang-js">const options = {
  headerPrefix: &#39;header-id&#39;,
};
const renderer = new marked.Renderer(options);
const output = renderer.heading(&#39;hello world&#39;, 2, &#39;&#39;);

// output: &#39;&lt;h2 id=&quot;header-id&quot;&gt;hello world&lt;/h2&gt;&#39;
</code></pre>
<p>我们可以看到在marked中，Renderer上的方法生成的内容就是我们所期望的HTML内容了。</p>
<h3 id="parser">Parser</h3>
<pre><code class="lang-js">const tokens = marked.Lexer.lex(&#39;# hello world&#39;);
const output = marked.Parser.parse(tokens);
// output: &lt;h1 id=&quot;hello-world&quot;&gt;hello world&lt;/h1&gt;
</code></pre>
<p>因为markdown的语法规则不像编程语言一样复杂，所以marked中的Parser相对简单，基本上就是按顺序将tokens转换成转换成HTML内容。</p>
<h2 id="-marked">实践：扩展marked</h2>
<p>为了验证对marked的理解是否正确，我试着fork并修改了marked的代码（<a href="https://github.com/oyyd/marked-chartjs-binding">github地址</a>），绑定了chartjs，令我们可以在markdown中调用渲染图表。</p>
<p>你可以在这篇关于<a href="https://blog.oyyd.net/post/introduce_universal_javascript_and_its_implementation_in_static_pages">Universal React</a>的文章底部的benchmark部分看到柱状图。</p>
<p>在修改中，我加入了如下的语法：</p>
<pre><code class="lang-md">graph.chartName
// JSON data here which will be used by
endgraph
</code></pre>
<p>其中chartName将被用作chartjs的图表名，如：graph.Bar将使用chartjs中的Bar表。其对应的token形如：</p>
<pre><code class="lang-js">{
  type: &#39;graph&#39;,
  name: &#39;chartName&#39;, // chartn
  data: &#39;...&#39; // expecting JSON string containing `data` and `options` as the parameters of Chart
}
</code></pre>
<p>而在<code>graph.chartName</code>和<code>endgraph</code>之间的内容将作为图表的参数。修改过后的marked最终渲染出如下的内容：</p>
<pre><code class="lang-html">&lt;script type=&quot;text/chartdata&quot; data-chartname=&quot;chartName&quot;
  style=&quot;display:none;&quot;&gt;
// ...json string here
&lt;/script&gt;
</code></pre>
<p>事实上我们只是渲染了一个script标签来保留图表信息，修改过后的marked并不能让我们在浏览器上直接看到图表。这是由于浏览器的限制，涉及到script的内容在处理时会遇到各种问题，所以在我的处理里，我使用<code>renderCharts()</code>方法去文档中搜索这样的标签，从而真正地渲染图表。</p>
<h2 id="-">相关链接</h2>
<p><a href="http://programmers.stackexchange.com/questions/165543/how-to-write-a-very-basic-compiler">How to write a very basic compiler</a></p>
<p><a href="http://stackoverflow.com/questions/2842809/lexers-vs-parsers">lexers vs parsers</a></p>
]]></description>
            <link>https://blog.oyyd.net/post/javascript_compiler_marked</link>
            <guid isPermaLink="false">d1d5084ec80418fd578b0a8d67e82bcc</guid>
            <pubDate>Sun, 03 Jan 2016 16:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[探究用ES6 template strings替代前后端模板引擎]]></title>
            <description><![CDATA[<h1 id="-es6-template-strings-">探究用ES6 template strings替代前后端模板引擎</h1>
<p><strong>补充：</strong> 后来我发现我的想法有些接近<a href="https://github.com/aui/artTemplate">artTemplate</a>的想法，感兴趣的朋友值得一试。</p>
<p><strong>前言：</strong></p>
<p>JavaScript上有很多的模板引擎，不管是用于前端的、后端的、两者兼顾的，或是特性丰富的，或是在模板中尽可能减少逻辑的，选择十分丰富。如果你也曾在一个或大或小的项目中考虑如何选择模板引擎的话，那你肯定也和我一样犹豫过要怎么选择。</p>
<p>另一方面，在我大量使用React的工作时间中，我越发认可React中jsx的设计<sup id="1" class="margin-toggle sidenote-number">1</sup><span for="1" class="mdl-tooltip sidenote"><a href="http://blog.vjeux.com/2013/javascript/jsx-e4x-the-good-parts.html">JSX: E4X The Good Parts</a></span> 。而当我从React jsx的角度考虑一个好的模板引擎应该具有什么样的特性时，我意识到，对于比较简单的情形，使用ES6中的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">template strings</a>外加一些约定就已经足矣。你甚至不需要模板引擎就能够很好地处理绝大多数你以前需要用模板引擎来处理的工作。</p>
<p>那么下面就让我们来简单地探讨一下用ES6 template strings替代模板引擎的可行性及其优劣。</p>
<h2 id="-">一个简单的实例</h2>
<p>像是我的这个博客的一部分模板工作是直接利用template strings完成的（剩下的是React renderToString完成的）：</p>
<p>head标签的模板:</p>
<pre><code class="lang-js">// createHead.js
function createHead(ctx) {
  let {title, description} = ctx;

  return (
    `&lt;head&gt;
      &lt;title&gt;${title}&lt;/title&gt;
      &lt;meta name=&quot;description&quot; content=&quot;${description}&quot;/&gt;
      &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
      &lt;link rel=&quot;shortcut icon&quot; href=&quot;/static/favicon.ico&quot; /&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/static-lib/codemirror/codemirror.css&quot;/&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/static-lib/codemirror/theme/monokai-sublime.css&quot;/&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/style.css&quot;/&gt;
    &lt;/head&gt;`
  );
}

export default createHead;
</code></pre>
<p>使用head标签模板，并引入每个页面的具体内容：</p>
<pre><code class="lang-js">// createPage.js
import createHead from &#39;./createHead&#39;;

function createPage(ctx) {
  let {title, description, content, initialState} = ctx;

  title = title || &#39;oyyd blog&#39;;
  description = description || &#39;这是亚东的博客，你可以在上面看到我的一些想法和实践，欢迎来访。&#39;;
  initialState = initialState || &#39;null&#39;;

  return (
    `&lt;!DOCTYPE html&gt;
    &lt;html&gt;
      ${createHead({title, description})}
      &lt;body&gt;
        &lt;div id=&quot;main&quot;&gt;${content}&lt;/div&gt;
        &lt;script&gt;
          window.__INITIAL_STATE__ = JSON.parse(&quot;${initialState}&quot;);
        &lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/codemirror.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/mode/javascript/javascript.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/static-lib/codemirror/mode/xml/xml.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
          (function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,&#39;script&#39;,&#39;//www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);

          ga(&#39;create&#39;, &#39;UA-70462946-1&#39;, &#39;auto&#39;);
          ga(&#39;send&#39;, &#39;pageview&#39;);
        &lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;`
  );
}

export default createPage;
</code></pre>
<p>这样，我们就在没有引入模板引擎的情况下，完成了这些简单的工作。</p>
<h2 id="-api-">对比实现其他模板引擎中的一些API与特性</h2>
<p>为了进一步探讨用template strings替代模板引擎的可行性，我们将对比实现其他模板引擎中的一些特性。</p>
<p>这里我们挑选的是<a href="http://mozilla.github.io/nunjucks/templating.html">nunjucks</a>中的一些特性，因其特性相对强大，更容易帮助我们说明template strings的特点及局限性。</p>
<p>另外，如果有些什么是template strings没有，而其他模板引擎做得到的话，你可以考虑用其他javascript的方式来实现，毕竟 <strong>你可以直接使用javascript这一强大的语言环境，通常再写一个函数/模板都能解决你的问题</strong>。并且相比于评价其好坏，你可能更需要去思考一下你是否真的需要这一特性。</p>
<h3 id="-">表达式</h3>
<p>nunjucks:</p>
<pre><code class="lang-html">{{ numItems*2 }}
</code></pre>
<p>template strings本身接受的就是表达式：</p>
<pre><code class="lang-js">`
${ numItems * 2 }
`
</code></pre>
<h3 id="if-else">if else</h3>
<p>nunjucks中的条件语句十分灵活：</p>
<pre><code class="lang-html">{% if hungry %}
  I am hungry
{% elif tired %}
  I am tired
{% else %}
  I am good!
{% endif %}
</code></pre>
<p>因为template strings只接受表达式的值，所以你最多只能用boolean-exp：</p>
<pre><code class="lang-js">`
${ hungry ? (
  I am hungry
) : (
  I am not hungry
) }
`
</code></pre>
<h3 id="for">for</h3>
<p>假设我们有：</p>
<pre><code class="lang-js">var points = [[0, 1, 2], [5, 6, 7], [12, 13, 14]];
</code></pre>
<p>在nunjucks中的：</p>
<pre><code class="lang-html">{% for x, y, z in points %}
  Point: {{ x }}, {{ y }}, {{ z }}
{% endfor %}
</code></pre>
<p>虽然template strings只接受表达式，但还是可以这样完成实现:</p>
<pre><code class="lang-js">`${points.map(({x, y, z}) =&gt; (
  `Point: ${x}, ${y}, ${z}`
)).join(&#39;&#39;)}`
</code></pre>
<h3 id="-asynceach-asyncall">异步操作asyncEach与asyncAll</h3>
<p>nunjucks支持一些异步操作：</p>
<pre><code class="lang-html">&lt;h1&gt;Posts&lt;/h1&gt;
&lt;ul&gt;
{% asyncAll item in items %}
  &lt;li&gt;{{ item.id | lookup }}&lt;/li&gt;
{% endall %}
&lt;/ul&gt;
</code></pre>
<p>我们没办法直接在template strings中做这件事。但如果只是进行简单的异步操作的话，我们可以在外部进行处理，并且这和其他用javascript处理异步操作的情况一致：</p>
<pre><code class="lang-js">function renderPosts(posts) {
  return new Promise((resolve, reject) =&gt; {
    let content = &#39;&#39;;

    // 写些异步操作来修改content
    // ...

    resolve(`
      &lt;h1&gt;Posts&lt;/h1&gt;
      &lt;ul&gt;
        ${content}
      &lt;/ul&gt;
    `);
  });
}
</code></pre>
<p>但如果想要我们的模板整体支持异步的话，我们就需要写一些额外的代码来做这件事。而避免在你的模板中使用异步操作也是个选择。</p>
<h3 id="autoescaping">Autoescaping</h3>
<p>在nunjucks中，当<code>autoescape</code>选项被设置为<code>true</code>时，nunjucks会默认地转义变量的值，以防止可能来自用户的攻击。在使用template strings时，我们不难转义单个变量的值：</p>
<pre><code class="lang-js">var username = &#39;&lt;script&gt;&lt;/script&gt;&#39;;

function escapeHTML(str) {
  // 具体实现，或是直接使用lodash.escape等
}

return `&lt;div&gt;{ escapeHTML(username) }&lt;/div&gt;`;
// &lt;div&gt;&amp;lt;script&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt;&lt;/div&gt;
</code></pre>
<p>而如果我们不想每次都手动调用转义函数，而是想要默认转义所有变量的值的话，我们可以利用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings#Tagged_template_strings">Tagged template strings</a>这一特性：</p>
<pre><code class="lang-js">function escapeHTML(str) {
  // 具体实现，或是直接使用lodash.escape等
}

function escape(strings, ...values) {
  return strings.map((str, index) =&gt; (
    index === 0 ? `${str}` : `${str}${escapeHTML(values[index - 1])}`
  )).join(&#39;&#39;);
}

return escape`&lt;div&gt;{ uesrname }&lt;/div&gt;`;
// &lt;div&gt;&amp;lt;script&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt;&lt;/div&gt;
</code></pre>
<p>Tagged template strings这一特性很强大，你需要去充分利用它<sup id="2" class="margin-toggle sidenote-number">2</sup><span for="2" class="mdl-tooltip sidenote">Tagged templates invite library designers to create powerful domain-specific languages. ——<a href="https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/">ES6 In Depth: Template strings</a></span> 。</p>
<h3 id="comments">comments</h3>
<p>在nunjucks中我们可以写注释：</p>
<pre><code class="lang-html">{# Loop through all the users #}
{% for user in users %}...{% endfor %}
</code></pre>
<p>并且模板中的注释在生成的字符串中会被自动截掉。如果我们想在template strings中写注释的话，我们就需要直接写成HTML的注释：</p>
<pre><code class="lang-js">`
&lt;!-- Loop through all the users --&gt;
`
</code></pre>
<p>那么我们能否在模板生成的字符串中自动截取掉这些注释呢？那我们还是要利用tagged template strings：</p>
<pre><code class="lang-js">function trimComments(str) {
  return str.replace(/&lt;!--.*?--&gt;/g, &#39;&#39;);
}

function escape(strings, ...values) {
  return strings.map((str, index) =&gt; (
    index === 0 ? `${trimComments(str)}` : `${trimComments(str)}${trimComments(values[index - 1])}`
  )).join(&#39;&#39;);
}

return escape`
  &lt;!-- Loop through all the users --&gt;
`;
</code></pre>
<h3 id="-">动态生成模板</h3>
<p>大部分模板引擎都可以动态生成模板，因为生成模板的过程实际上是在js上进行的一次编译过程，比如在nunjucks中：</p>
<pre><code class="lang-js">var username = &#39;James&#39;;
var template = &#39;Hello {{ username }}&#39;;
var res = nunjucks.renderString(template, { username: username });
</code></pre>
<p>我们可以通过eval方法来动态生成模板：</p>
<pre><code class="lang-js">var username = &#39;James&#39;;
var template = &#39;`Hello ${ username }`&#39;;
// 你应该需要更稳健的写法
var res = eval(template);
</code></pre>
<h2 id="-template-strings-">用template strings替代模板引擎的优点和缺点</h2>
<p>到目前位置，我们主要讨论了用template strings来替代模板引擎的可行性，下面我们会讨论这样做的优点和缺点。</p>
<p>模板引擎是<a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>，其目的是拼接字符串。没有模板引擎我们当然也可以拼接字符串，只不过这一过程会很痛苦。而template strings本身就是为了解决这一问题而设计的，而tagged template strings又足够帮助我们实现模板引擎的功能<sup id="3" class="margin-toggle sidenote-number">3</sup><span for="3" class="mdl-tooltip sidenote">利用tagged template strings开发DSL当然也是可行的，这里的讨论不涉及开发DSL的情况</span> 。</p>
<p>由于各种原因，通常模板引擎在处理很多问题时，通常会有自己的一套方法，比如说在一个模板中引入另一个模板你可能需要用import/require/partials语句，这实际上和JavaScript本身的import解决的是相似的问题。所以在使用template strings时，面对这些情况，我们就可以直接利用JavaScript中的特性来实现，而不需要像那样用一套新的东西来解决相似的问题。</p>
<p>这样很自然地，使用template strings替代模板引擎最主要的优点在于：</p>
<ol>
<li><p>贴近原生JavaScript，学习曲线更低。</p>
</li>
<li><p>你可以充分利用已有的JavaScript代码和特性，任何新的需求都可以通过你熟悉的JavaScript进行拓展。</p>
</li>
<li><p>你的模板部分的内容天然就是Universal JavaScript，你天然地就可以同时在浏览器上和服务器上使用模板相关的代码。</p>
</li>
</ol>
<p>但模板引擎毕竟是专门为处理模板而生的，有些用JavaScript实现比较麻烦的场景，用模板引擎的语法可能可以轻松地解决。实际上这里的讨论更像是在讨论使用DSL的优缺点。但使用template strings的理由在于 <strong>很多模板引擎上的很多特性都和JavaScript（ES6+）本身的特性重合了，我们没必要用一套新东西解决同样的问题</strong>。当然在ES6之前，JavaScript本身也没有模块，更别说考虑直接使用JavaScript中的特性来解决模板上的问题。</p>
<p>而另一个推荐使用template strings的原因在于Universal JavaScript。如果模板本身就是JavaScript代码的话，那么在前后端同时使用一份代码会变得容易得多。</p>
<p>另外不分离模板与代码的这一想主要是受到React的启发。React中的HTML(Virtual DOM, React DOM)部分和JavaScript代码紧密贴合<sup id="4" class="margin-toggle sidenote-number">4</sup><span for="4" class="mdl-tooltip sidenote">这里主要是对比Angular和Polymer等框架，即主要由JavaScript代码控制HTML内容，而不是以HTML为主，也不是HTML和JavaScript平分秋色</span> 的想法，至少从实践角度上来说是很有效的，它使得代码十分容易维护。那么对于模板来说，不去刻意分离模板代码与普通的代码、模板代码既是JavaScript代码或许是个好的思路。</p>
<h2 id="-">生产环境上的应用</h2>
<p>在生产环境上单单使用template strings没办法解决我们的所有需求，而截止至本文时点我也没有看见过任何类似的实现。所以如果你觉得这是个好主意，你需要充分利用tagged template strings这一特性来组织起模板层。万幸的是这一过程不需要涉及编译，所以这会远比重新写一个模板引擎要简单得多。之后我也会尝试写一个帮助实现这一目的的库。</p>
<h2 id="-">其他相关链接</h2>
<p><a href="http://www.2ality.com/2015/01/template-strings-html.html">HTML templating with ES6 template strings</a></p>
]]></description>
            <link>https://blog.oyyd.net/post/best_template_engine_in_node_js</link>
            <guid isPermaLink="false">e376e1b601f9fe30966dd8f5ca201e23</guid>
            <pubDate>Tue, 15 Dec 2015 16:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>